# replication
복제는 비동기 모드로 작동한다. 따라서 복제 시간의 차이는 수초에서 수분, 최악의 경우 수 시간이 될 수도 있다.  
복제는 모든 데이터 베이스, 선택된 데이터베이스, 데이터베이스의 일부 테이블 모두 가능하다.

### 복제의 동작 방식
1. 클라이언트가 마스터에 쓰기 트랜잭션을 요청
2. 바이너리 로그(빈로그)가 업데이트된다. 데이터베이스의 변화에 대한 이벤트가 빈로그에 포함되어 있다.
3. 슬레이브가 마스터로부터 정보를 전달받는다.
4. 슬레이브는 이 정보를 릴레이 로그에 첨부한다.
5. 슬레이브 SQL 스레드는 릴레이 로그에 있는 명령문을 반복한다.

#### 복제 메커니즘
1. 표준 복제: 각 노드는 자신만의 트렌잭션 ID를 갖는다
2. 글로벌 트렌잭션 ID(GTID) 복제: 각 노드는 모든 복제 노드에서 같은 트랜잭션 ID를 가진다(mariaDB 10부터 지원)

#### 마스터/슬레이브 노드 옵션
* server-id: 유일한 ID이어야 한다(1 ~ 2^32-1 범위)
* bind-address: MariaDB 인스턴스가 listen할 IP 주소.(0.0.0.0으로 설정 시 이용 가능한 모든 인터페이스 연결)
* log-bin: 바이너리 로그 저장 위치
* expire_log_days: 빈로그 저장 기간.(마스터와 슬레이브 사이의 차이가 이보다 크면 복제할 수 없고 전체 동기화를 해야한다.)
* sync_binlog:쓰기할 때마다 이벤트 후에 바이너리 로그 파일을 디스크에 동기화(플러시)한다. 1일 경우 활성화. 가장 안전하며 가장 느리다. 복제 성능을 위해서는 비활성화 시킨다.
* slave_compressed_protocolL 슬레이브가 이 옵션을 함께 설정하면 압축을 사용한다. CPU 사용량을 높이지만 복제가 빨라진다.
* binlog_format: 빈로그 형식(row: 행 기반 데이터 로깅, statement: 명령문 기반 데이터 로깅, mixed: 혼합 로깅)
* read_only: 선행 명령에 사용된다. 슬레이브에 해당 옵션 추가 시, 쓰기 작업을 비활성화 할 수 있다.

### GTID 복제
빈로그의 각 트랜잭션에 새로운 이벤트를 추가한다. 모든 복제된 서버에 유일한 식별자를 제공하는 것이 전통적인 복제와 다른 점이다. 가장 큰 이점은 모든 노드에서 동일한 트랜잭션 ID를 얻을 수 있으므로 마스터를 쉽게 바꿀 수 있으며 슬레이브가 충돌방지 방식으로 저장된다는 것이다. 완벽한 충돌방지를 위해 InnoDB와 같은 트랜잭션 엔진을 사용하는 것도 포함한다.  
전통적인 복제와 가장 큰 차이점은 마지막에 적용된 트랜잭션의 GTID가 데이터베이스의 gtid_slave_pos 파일에 저장되는 것이다. 이 테이블은 트랜잭션이 작성될 때마다 업테이트 된다. 슬레이브가 충돌하면 마지막 상태 위치를 쉽게 찾을 수 있고 마지막 트랜잭션 커밋과 일치하는지 마스터를 확인할 수 있다.  
GTID 형식: [도메인ID]-[서버ID]-[숫자]  
* gtid_strict_mode: 해당 옵션에 1을 입력해 활성화 시 GTID를 사용해 모든 복제된 노드간에 정확한 빈로그를 갖도록 한다.  
* master_user_gtid: 마스터-슬레이브 복제 구성 방식 결정 (
  * slave_pos: 슬레이브는 자체적으로 유지하는 마지막 GTID 위치에서 복제를 시작,  
  * current_pos: 슬레이브는 가장 최근의 GTID 위치에서 복제를 시작. 이는 현재 마스터의 복제 상태와 직접 동기화. gtid_strict_mode 사용 시 슬레이브 서버의 빈로그에 추가적인 트랜잭션이 삽입될 수도 있다.
  * no: GTID를 비활성화) 

### 병렬 복제
복제는 기본적으로 단일 스레드로 동작한다. 병렬 복제를 활성화하지 않은 상태에서 멀티소스가 복제된다면 성능상의 문제가 생길 수 있다.  
병렬 복제를 사용하기 위해서는 MariaDB 설정파일(my.cnf)레 다음 라인을 추가한다.  
slave-parallel-threads=4(0:비활성화 ~ 16383:최대값)  
추가적인 옵션은 다음과 같다.
* slave_parallel_max_queued: SQL 스레드를 위한 메모리 제한 값  
* slave_domain_parallel_threads: 마스터가 (한번에)최대로 예약할 수 있는 연결의 수  
* binlog_commit_wait_count: 바이너리 로그에서 I/O를 줄여준다. 슬레이브에 병렬 복제가 잘 되도록 도움을 준다.  
* binlog_commit_wait_usec: 바이너리 로그가 그룹 커밋을 위한 큐를 몇 마이크로 초까지 기다릴지 설정한다.  

### 슬레이브를 마스터로 교체하고 복구하기
1. 쓰기 작성을 위해 기존 마스터 대신 슬레이브로 애플리케이션 연결 설정을 변경한다.
2. 설정에서 read_only 인자를 삭제하고 MariaDB를 다시 시작한다. 또는 바로 적용한다.  
```
SET GLOBAL read_only=0;
```
3. 다음 명령으로 슬레이브 메커니즘을 중지한다.
```
stop slave;
```
4. 슬레이브(새로운 마스터) 노드에서 복제 계정을 생성한다.
```
create user 'replication'@'접속하는ip주소' identified by 'password';
grant replication slave on *.* to 'replication'@'접속하는ip주소';
flush privileges;
```
이때 문제점은 기존 마스터가 슬레이브였던 적이 없다는 것이다.
따라서 변경된 사항을 다시 얻기 위해 기존 마스터를 수정한다.
```
change master to
master_host='새로운 마스터 ip주소', master_user='replication',
master_password='password', master_use_gtid=current_pos;
start slave;
```
5. 이제 기존 마스터를 확인하면 모든 정보가 최신 상태가 된다.
6. 새로운 마스터를 중지시켜 이 서버로 연결되지 않게 한다.
7. 애플리케이션을 기존 마스터로 가도록 다시 설정한다.
8. 마스터에서 stop slave 명령으로 슬레이브 복제를 중지한다.
9. 새로운 마스터를 service mysql start를 통해 슬레이브로 다시 시작한다.
10. 다른 노드에도 복구하고 싶다면 같은 방식으로 수행한다.
```
change master to
master_host='기존 마스터 ip주소', master_user='replication',
master_password='password', master_use_gtid=current_pos;
start slave;
```

### 이중 마스터 복제
두개의 마스터가 서로를 슬레이브로 갖는다면 이는 이중 마스터 복제라고 할 수 있다. 하지만 이 경우 양쪽 호스트간의 데이터가 불일치할 수 있고 (키 충돌로 인해) 복제가 깨질 수 있으며, 최악의 경우 두 호스트간 데이터가 불일치된 상태로 끝날 수 있다.  
MariaDB 설정 파일에 아래 두개의 옵션을 추가함으로써 이런 문제를 최소화 할 수 있다. (같은 테이블의 같은 열에서 기본 키 충돌을 피할 수 있다.)  
* auto-increment-increment: 자동증가 필드의 증가량 설정. 여기에 마스터의 개수를 설정한다.  
* auto-increment-offset: 자동증가 필드의 시작점 설정. 유일한 숫자(server-id)를 설정한다.  
